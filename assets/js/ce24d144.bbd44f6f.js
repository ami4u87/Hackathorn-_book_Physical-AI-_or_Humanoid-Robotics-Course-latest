"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[108],{8148:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=i(4848),s=i(8453);const a={},r="Physics Validation",o={id:"module-2-simulation/physics",title:"Physics Validation",description:"Ensuring that your robot simulation accurately represents real-world physics is critical for successful sim-to-real transfer. This lesson covers techniques for validating and tuning physics parameters in your simulation environments.",source:"@site/docs/module-2-simulation/4-physics.md",sourceDirName:"module-2-simulation",slug:"/module-2-simulation/physics",permalink:"/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/docs/module-2-simulation/physics",draft:!1,unlisted:!1,editUrl:"https://github.com/ami4u87/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/tree/master/docs/module-2-simulation/4-physics.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"docsSidebar",previous:{title:"NVIDIA Isaac Sim",permalink:"/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/docs/module-2-simulation/isaac"},next:{title:"Module 2 Exercises",permalink:"/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/docs/module-2-simulation/exercises"}},l={},c=[{value:"Why Physics Validation Matters",id:"why-physics-validation-matters",level:2},{value:"Key Physics Parameters",id:"key-physics-parameters",level:2},{value:"1. Mass and Inertia",id:"1-mass-and-inertia",level:3},{value:"2. Joint Friction and Damping",id:"2-joint-friction-and-damping",level:3},{value:"3. Contact Parameters",id:"3-contact-parameters",level:3},{value:"4. Actuator Models",id:"4-actuator-models",level:3},{value:"Validation Experiments",id:"validation-experiments",level:2},{value:"1. Trajectory Tracking",id:"1-trajectory-tracking",level:3},{value:"2. Energy Consumption",id:"2-energy-consumption",level:3},{value:"3. Impact Testing",id:"3-impact-testing",level:3},{value:"Simulator-Specific Tuning",id:"simulator-specific-tuning",level:2},{value:"Gazebo",id:"gazebo",level:3},{value:"Isaac Sim",id:"isaac-sim",level:3},{value:"Unity",id:"unity",level:3},{value:"Domain Randomization",id:"domain-randomization",level:2},{value:"Validation Checklist",id:"validation-checklist",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"physics-validation",children:"Physics Validation"}),"\n",(0,t.jsx)(n.p,{children:"Ensuring that your robot simulation accurately represents real-world physics is critical for successful sim-to-real transfer. This lesson covers techniques for validating and tuning physics parameters in your simulation environments."}),"\n",(0,t.jsx)(n.h2,{id:"why-physics-validation-matters",children:"Why Physics Validation Matters"}),"\n",(0,t.jsx)(n.p,{children:'The "reality gap" between simulation and real-world behavior can cause:'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Controller Failure"}),": Controllers that work in simulation fail on real hardware"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unsafe Behavior"}),": Robots that are stable in simulation become unstable in reality"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Training Inefficiency"}),": RL policies trained in poor simulations don't transfer"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Wasted Resources"}),": Time spent debugging hardware when the issue is in simulation"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Proper physics validation minimizes these risks."}),"\n",(0,t.jsx)(n.h2,{id:"key-physics-parameters",children:"Key Physics Parameters"}),"\n",(0,t.jsx)(n.h3,{id:"1-mass-and-inertia",children:"1. Mass and Inertia"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why It Matters"}),": Incorrect mass distribution affects dynamics, balance, and energy consumption."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Validation Process"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Check mass properties in simulation\ndef validate_mass_properties(robot_urdf, real_mass_kg):\n    """Compare simulated vs real mass"""\n    # Parse URDF to get total mass\n    sim_total_mass = calculate_urdf_mass(robot_urdf)\n\n    error_percent = abs(sim_total_mass - real_mass_kg) / real_mass_kg * 100\n\n    if error_percent > 5:\n        print(f"\u26a0\ufe0f Mass error: {error_percent:.2f}%")\n        print(f"Simulated: {sim_total_mass:.2f}kg, Real: {real_mass_kg:.2f}kg")\n        return False\n    else:\n        print(f"\u2713 Mass validated: {error_percent:.2f}% error")\n        return True\n\n# Example usage\nvalidate_mass_properties("humanoid.urdf", real_mass_kg=45.0)\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Measuring Real Inertia"}),":"]}),"\n",(0,t.jsxs)(n.p,{children:["For complex shapes, use the ",(0,t.jsx)(n.strong,{children:"bifilar pendulum"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\ndef calculate_inertia_from_pendulum(mass_kg, length_m, period_s):\n    """\n    Calculate moment of inertia from bifilar pendulum test\n\n    Args:\n        mass_kg: Mass of the object\n        length_m: Length of pendulum strings\n        period_s: Measured oscillation period\n\n    Returns:\n        Moment of inertia (kg\u22c5m\xb2)\n    """\n    g = 9.81  # m/s\xb2\n    I = (mass_kg * g * length_m * period_s**2) / (4 * np.pi**2)\n    return I\n\n# Example: Measured period of 2.3 seconds\nreal_inertia = calculate_inertia_from_pendulum(\n    mass_kg=5.0,\n    length_m=0.5,\n    period_s=2.3\n)\nprint(f"Measured inertia: {real_inertia:.4f} kg\u22c5m\xb2")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-joint-friction-and-damping",children:"2. Joint Friction and Damping"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Static vs Dynamic Friction"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In URDF/SDF --\x3e\n<joint name="knee_joint" type="revolute">\n  <dynamics damping="0.7" friction="0.5"/>\n  \x3c!-- damping: velocity-dependent resistance (N\u22c5m\u22c5s/rad) --\x3e\n  \x3c!-- friction: static friction (N\u22c5m) --\x3e\n</joint>\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Validation Experiment"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Free Swing Test"}),": Release joint from angle and measure decay"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compare with Simulation"}),": Tune damping until curves match"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import matplotlib.pyplot as plt\nimport numpy as np\n\ndef fit_damping_coefficient(time_data, angle_data, inertia):\n    """\n    Fit damping coefficient from free swing data\n\n    Damped oscillation: \u03b8(t) = A\u22c5e^(-bt)\u22c5cos(\u03c9t + \u03c6)\n    """\n    from scipy.optimize import curve_fit\n\n    def damped_oscillation(t, A, b, omega, phi):\n        return A * np.exp(-b * t) * np.cos(omega * t + phi)\n\n    # Fit parameters\n    popt, _ = curve_fit(damped_oscillation, time_data, angle_data)\n    A, b, omega, phi = popt\n\n    # Calculate damping coefficient\n    damping = 2 * b * inertia\n\n    return damping, popt\n\n# Example data from real robot\ntime_real = np.linspace(0, 5, 100)\nangle_real = np.load(\'real_joint_swing.npy\')  # Your measured data\n\ninertia = 0.05  # kg\u22c5m\xb2\ndamping, params = fit_damping_coefficient(time_real, angle_real, inertia)\n\nprint(f"Optimal damping coefficient: {damping:.4f} N\u22c5m\u22c5s/rad")\n\n# Plot comparison\nplt.plot(time_real, angle_real, label=\'Real Robot\')\n# ... plot simulation data with tuned damping\nplt.legend()\nplt.show()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-contact-parameters",children:"3. Contact Parameters"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Contact Model Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stiffness"}),' (kp): How "hard" surfaces are']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Damping"})," (kd): Energy dissipation at contact"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Friction coefficients"}),": \u03bc_static, \u03bc_dynamic"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Validation: Drop Test"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def validate_contact_stiffness(drop_height_m, bounce_height_m, mass_kg):\n    """\n    Estimate contact parameters from drop test\n\n    Coefficient of restitution: e = sqrt(h_bounce / h_drop)\n    """\n    e = np.sqrt(bounce_height_m / drop_height_m)\n\n    # For contact modeling\n    print(f"Coefficient of restitution: {e:.3f}")\n\n    if e < 0.1:\n        print("\u2192 Use high damping (kd > 100)")\n    elif e > 0.7:\n        print("\u2192 Use low damping (kd < 50)")\n\n    return e\n\n# Example: Drop from 0.5m, bounces to 0.05m\nvalidate_contact_stiffness(drop_height_m=0.5, bounce_height_m=0.05, mass_kg=2.0)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Friction Validation: Incline Test"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def measure_friction_coefficient(incline_angle_deg):\n    """\n    Measure static friction from incline test\n\n    At the angle of slipping: \u03bc_s = tan(\u03b8)\n    """\n    theta_rad = np.deg2rad(incline_angle_deg)\n    mu_static = np.tan(theta_rad)\n\n    print(f"Static friction coefficient: {mu_static:.3f}")\n    return mu_static\n\n# Example: Object slips at 25 degrees\nmu = measure_friction_coefficient(25)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Update simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Gazebo/SDF --\x3e\n<surface>\n  <friction>\n    <ode>\n      <mu>0.8</mu>    \x3c!-- static friction --\x3e\n      <mu2>0.6</mu2>  \x3c!-- dynamic friction --\x3e\n    </ode>\n  </friction>\n  <contact>\n    <ode>\n      <kp>1000000</kp>  \x3c!-- stiffness --\x3e\n      <kd>100</kd>      \x3c!-- damping --\x3e\n    </ode>\n  </contact>\n</surface>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-actuator-models",children:"4. Actuator Models"}),"\n",(0,t.jsx)(n.p,{children:"Real motors have:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Torque limits"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Velocity limits"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Back-EMF"})," (torque decreases at high speed)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gear ratios"})," and ",(0,t.jsx)(n.strong,{children:"transmission losses"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Realistic Motor Model"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class DCMotorModel:\n    """Simplified DC motor with back-EMF"""\n\n    def __init__(self, stall_torque, no_load_speed, voltage):\n        """\n        Args:\n            stall_torque: Maximum torque at 0 speed (N\u22c5m)\n            no_load_speed: Maximum speed at 0 load (rad/s)\n            voltage: Operating voltage (V)\n        """\n        self.tau_stall = stall_torque\n        self.omega_max = no_load_speed\n        self.V = voltage\n\n    def get_torque(self, angular_velocity, voltage_cmd):\n        """\n        Calculate actual output torque\n\n        Torque-speed relationship: \u03c4 = \u03c4_stall * (1 - \u03c9/\u03c9_max) * (V_cmd/V_nom)\n        """\n        voltage_factor = voltage_cmd / self.V\n        speed_factor = max(0, 1 - abs(angular_velocity) / self.omega_max)\n\n        torque = self.tau_stall * speed_factor * voltage_factor\n\n        return torque\n\n# Example: Dynamixel MX-64 specs\nmotor = DCMotorModel(\n    stall_torque=6.0,      # N\u22c5m\n    no_load_speed=116.0,   # RPM \u2192 rad/s\n    voltage=12.0\n)\n\n# At half speed, full voltage\ntorque = motor.get_torque(angular_velocity=58.0, voltage_cmd=12.0)\nprint(f"Output torque: {torque:.2f} N\u22c5m")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Integrate into simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# In Gazebo plugin or Isaac Sim controller\ndef apply_motor_command(joint, desired_torque, current_velocity):\n    """Apply realistic motor limits"""\n\n    # Get actual torque from motor model\n    actual_torque = motor.get_torque(current_velocity, desired_torque)\n\n    # Apply limits\n    actual_torque = np.clip(actual_torque, -motor.tau_stall, motor.tau_stall)\n\n    joint.set_torque(actual_torque)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"validation-experiments",children:"Validation Experiments"}),"\n",(0,t.jsx)(n.h3,{id:"1-trajectory-tracking",children:"1. Trajectory Tracking"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Test"}),": Command a known trajectory, compare sim vs real"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def trajectory_tracking_test(sim_data, real_data):\n    \"\"\"\n    Compare trajectory tracking performance\n\n    Args:\n        sim_data: (time, position) from simulation\n        real_data: (time, position) from real robot\n    \"\"\"\n    from scipy import interpolate\n\n    # Interpolate real data to match sim timestamps\n    interp_func = interpolate.interp1d(real_data['time'], real_data['position'])\n    real_interp = interp_func(sim_data['time'])\n\n    # Calculate RMSE\n    rmse = np.sqrt(np.mean((sim_data['position'] - real_interp)**2))\n\n    # Calculate correlation\n    correlation = np.corrcoef(sim_data['position'], real_interp)[0, 1]\n\n    print(f\"RMSE: {rmse:.4f} rad\")\n    print(f\"Correlation: {correlation:.4f}\")\n\n    # Plot\n    plt.figure(figsize=(10, 5))\n    plt.plot(sim_data['time'], sim_data['position'], label='Simulation')\n    plt.plot(real_data['time'], real_data['position'], 'o', label='Real Robot')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Joint Angle (rad)')\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n    return rmse, correlation\n\n# Example usage\nrmse, corr = trajectory_tracking_test(sim_data, real_data)\nif rmse < 0.05 and corr > 0.95:\n    print(\"\u2713 Validation passed!\")\nelse:\n    print(\"\u26a0\ufe0f Significant deviation detected\")\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-energy-consumption",children:"2. Energy Consumption"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Test"}),": Compare power consumption for same task"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def validate_energy_consumption(sim_power, real_power, duration):\n    """\n    Compare energy usage\n\n    Power = Torque \xd7 Angular_Velocity\n    """\n    sim_energy = np.trapz(sim_power, dx=duration)\n    real_energy = np.trapz(real_power, dx=duration)\n\n    error = abs(sim_energy - real_energy) / real_energy * 100\n\n    print(f"Simulated energy: {sim_energy:.2f} J")\n    print(f"Real energy: {real_energy:.2f} J")\n    print(f"Error: {error:.1f}%")\n\n    return error < 20  # 20% tolerance\n\n# Calculate power in simulation\ndef calculate_power(torques, velocities):\n    """Power = \u03c4 \xb7 \u03c9"""\n    return np.sum(torques * velocities, axis=1)  # Sum over all joints\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-impact-testing",children:"3. Impact Testing"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Test"}),": Drop robot or impact a surface, measure response"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def validate_impact_response(sim_impulse, real_impulse):\n    """\n    Compare impact forces and duration\n\n    Impulse = \u222b F dt\n    """\n    sim_peak = np.max(sim_impulse)\n    real_peak = np.max(real_impulse)\n\n    sim_duration = len(sim_impulse[sim_impulse > 0.1 * sim_peak]) * 0.001  # dt = 1ms\n    real_duration = len(real_impulse[real_impulse > 0.1 * real_peak]) * 0.001\n\n    print(f"Peak force - Sim: {sim_peak:.1f}N, Real: {real_peak:.1f}N")\n    print(f"Contact duration - Sim: {sim_duration:.3f}s, Real: {real_duration:.3f}s")\n\n    # Both should be similar for good validation\n    return abs(sim_peak - real_peak) / real_peak < 0.3\n'})}),"\n",(0,t.jsx)(n.h2,{id:"simulator-specific-tuning",children:"Simulator-Specific Tuning"}),"\n",(0,t.jsx)(n.h3,{id:"gazebo",children:"Gazebo"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Increase solver iterations for stability --\x3e\n<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <max_contacts>20</max_contacts>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>50</iters>  \x3c!-- Increase from default 20 --\x3e\n      <sor>1.3</sor>\n    </solver>\n  </ode>\n</physics>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"isaac-sim",children:"Isaac Sim"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from omni.isaac.core.utils.physics import set_physics_scene_settings\n\n# Tune physics parameters\nset_physics_scene_settings(\n    physics_dt=1.0/240.0,      # Higher frequency for accuracy\n    rendering_dt=1.0/60.0,\n    solver_type="TGS",          # Temporal Gauss-Seidel (more stable)\n    num_position_iterations=8,  # Increase for accuracy\n    num_velocity_iterations=1\n)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"unity",children:"Unity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Set physics timestep\nTime.fixedDeltaTime = 0.01f;  // 100Hz physics\n\n// Solver iterations\nPhysics.defaultSolverIterations = 10;\nPhysics.defaultSolverVelocityIterations = 5;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,t.jsxs)(n.p,{children:["To bridge the remaining reality gap, use ",(0,t.jsx)(n.strong,{children:"domain randomization"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def randomize_physics_parameters():\n    \"\"\"\n    Randomize physics to make RL policies more robust\n    \"\"\"\n    import random\n\n    # Randomize mass (\xb110%)\n    mass_multiplier = random.uniform(0.9, 1.1)\n\n    # Randomize friction (\xb130%)\n    friction_multiplier = random.uniform(0.7, 1.3)\n\n    # Randomize motor strength (\xb115%)\n    motor_multiplier = random.uniform(0.85, 1.15)\n\n    # Apply to robot\n    robot.set_mass_scale(mass_multiplier)\n    robot.set_friction_scale(friction_multiplier)\n    robot.set_motor_scale(motor_multiplier)\n\n    # Randomize timestep slightly\n    dt = random.uniform(0.0008, 0.0012)  # \xb120% around 0.001\n\n    return {\n        'mass': mass_multiplier,\n        'friction': friction_multiplier,\n        'motor': motor_multiplier,\n        'dt': dt\n    }\n"})}),"\n",(0,t.jsx)(n.h2,{id:"validation-checklist",children:"Validation Checklist"}),"\n",(0,t.jsx)(n.p,{children:"Before deploying to real hardware:"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Mass properties"}),": Total mass within 5% of real robot"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Inertia tensors"}),": Validated with pendulum or CAD"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Joint friction"}),": Free-swing test matches simulation"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Contact stiffness"}),": Drop test restitution coefficient matches"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Friction coefficients"}),": Incline test validates \u03bc values"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Motor limits"}),": Torque-speed curves match datasheets"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Trajectory tracking"}),": RMSE < 5% for simple motions"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Energy consumption"}),": Within 20% of real measurements"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Timestep"}),": Small enough (< 1ms for contacts)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,t.jsx)(n.strong,{children:"Solver iterations"}),": Sufficient for stability (> 20 iterations)"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Issue"}),(0,t.jsx)(n.th,{children:"Cause"}),(0,t.jsx)(n.th,{children:"Solution"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Robot falls through floor"}),(0,t.jsx)(n.td,{children:"Collision not detected"}),(0,t.jsx)(n.td,{children:"Reduce timestep, increase iterations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Jittery motion"}),(0,t.jsx)(n.td,{children:"Stiff contacts, low damping"}),(0,t.jsx)(n.td,{children:"Increase contact damping (kd)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Simulation too slow"}),(0,t.jsx)(n.td,{children:"Timestep too small"}),(0,t.jsx)(n.td,{children:"Increase timestep (if stable)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Robot explodes"}),(0,t.jsx)(n.td,{children:"Mass/inertia errors"}),(0,t.jsx)(n.td,{children:"Check URDF, verify positive inertia"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Drift over time"}),(0,t.jsx)(n.td,{children:"Numerical integration error"}),(0,t.jsx)(n.td,{children:"Use higher-order integrators"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2109.05590",children:"Physics-Based Simulation for Robot Learning"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2009.13303",children:"Sim-to-Real Transfer Survey"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"http://gazebosim.org/tutorials?tut=physics_params",children:"Gazebo Physics Parameters"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.omniverse.nvidia.com/isaacsim/latest/features/physics_settings.html",children:"Isaac Sim Physics"})}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);