"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[400],{8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>l});var s=i(6540);const o={},a=s.createContext(o);function r(n){const e=s.useContext(a);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),s.createElement(a.Provider,{value:e},n.children)}},8638:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var s=i(4848),o=i(8453);const a={},r="Gazebo Harmonic with ROS 2",l={id:"module-2-simulation/gazebo",title:"Gazebo Harmonic with ROS 2",description:"Gazebo is a powerful 3D robotics simulator that provides accurate physics simulation and sensor modeling. In this lesson, you'll learn to set up Gazebo Harmonic (the latest version) with ROS 2 and simulate humanoid robots.",source:"@site/docs/module-2-simulation/1-gazebo.md",sourceDirName:"module-2-simulation",slug:"/module-2-simulation/gazebo",permalink:"/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/docs/module-2-simulation/gazebo",draft:!1,unlisted:!1,editUrl:"https://github.com/ami4u87/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/tree/master/docs/module-2-simulation/1-gazebo.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Module 2: Simulation Environments",permalink:"/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/docs/module-2-simulation/"},next:{title:"Unity with ROS-TCP-Connector",permalink:"/Hackathorn-_book_Physical-AI-_or_Humanoid-Robotics-Course-latest/docs/module-2-simulation/unity"}},t={},c=[{value:"What is Gazebo Harmonic?",id:"what-is-gazebo-harmonic",level:2},{value:"Installation",id:"installation",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Installing Gazebo Harmonic",id:"installing-gazebo-harmonic",level:3},{value:"Installing ROS 2 - Gazebo Bridge",id:"installing-ros-2---gazebo-bridge",level:3},{value:"Launching Gazebo",id:"launching-gazebo",level:2},{value:"Basic Launch",id:"basic-launch",level:3},{value:"With ROS 2 Bridge",id:"with-ros-2-bridge",level:3},{value:"Creating a Humanoid Robot Model",id:"creating-a-humanoid-robot-model",level:2},{value:"SDF Format",id:"sdf-format",level:3},{value:"Spawning Robots in Gazebo",id:"spawning-robots-in-gazebo",level:2},{value:"Method 1: Using Launch Files",id:"method-1-using-launch-files",level:3},{value:"Method 2: Using ROS 2 Service",id:"method-2-using-ros-2-service",level:3},{value:"Controlling Robots in Gazebo",id:"controlling-robots-in-gazebo",level:2},{value:"Joint Control Plugin",id:"joint-control-plugin",level:3},{value:"Publishing Joint Commands",id:"publishing-joint-commands",level:3},{value:"Sensor Integration",id:"sensor-integration",level:2},{value:"Camera Feed to ROS 2",id:"camera-feed-to-ros-2",level:3},{value:"IMU Sensor",id:"imu-sensor",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"gazebo-harmonic-with-ros-2",children:"Gazebo Harmonic with ROS 2"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo is a powerful 3D robotics simulator that provides accurate physics simulation and sensor modeling. In this lesson, you'll learn to set up Gazebo Harmonic (the latest version) with ROS 2 and simulate humanoid robots."}),"\n",(0,s.jsx)(e.h2,{id:"what-is-gazebo-harmonic",children:"What is Gazebo Harmonic?"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo Harmonic is the latest generation of the Gazebo simulator, featuring:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Modern Architecture"}),": Complete rewrite with improved performance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Photorealistic Rendering"}),": Advanced graphics using Ogre 2.x"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Engines"}),": Support for multiple physics engines (Bullet, DART, ODE)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Simulation"}),": Cameras, LiDAR, IMU, force/torque sensors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS 2 Integration"}),": Native support via ros_gz packages"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(e.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(e.p,{children:"Before installing Gazebo Harmonic, ensure you have:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Ubuntu 22.04 (Jammy) or later"}),"\n",(0,s.jsx)(e.li,{children:"ROS 2 Humble or later"}),"\n",(0,s.jsx)(e.li,{children:"At least 4GB RAM and a dedicated GPU (recommended)"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"installing-gazebo-harmonic",children:"Installing Gazebo Harmonic"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Add Gazebo repository\nsudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg\necho "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/gazebo-stable.list > /dev/null\n\n# Update and install\nsudo apt update\nsudo apt install gz-harmonic\n'})}),"\n",(0,s.jsx)(e.h3,{id:"installing-ros-2---gazebo-bridge",children:"Installing ROS 2 - Gazebo Bridge"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Install ros_gz packages\nsudo apt install ros-humble-ros-gz\n\n# Source ROS 2\nsource /opt/ros/humble/setup.bash\n"})}),"\n",(0,s.jsx)(e.h2,{id:"launching-gazebo",children:"Launching Gazebo"}),"\n",(0,s.jsx)(e.h3,{id:"basic-launch",children:"Basic Launch"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Launch empty world\ngz sim empty.sdf\n\n# Launch with a specific world file\ngz sim worlds/shapes.sdf\n"})}),"\n",(0,s.jsx)(e.h3,{id:"with-ros-2-bridge",children:"With ROS 2 Bridge"}),"\n",(0,s.jsxs)(e.p,{children:["Create a launch file ",(0,s.jsx)(e.code,{children:"gazebo_sim.launch.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    # Path to Gazebo ROS package\n    pkg_ros_gz_sim = get_package_share_directory('ros_gz_sim')\n\n    # Gazebo launch\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(pkg_ros_gz_sim, 'launch', 'gz_sim.launch.py')\n        ),\n        launch_arguments={'gz_args': '-r empty.sdf'}.items(),\n    )\n\n    # Bridge ROS topics and Gazebo topics\n    bridge = Node(\n        package='ros_gz_bridge',\n        executable='parameter_bridge',\n        arguments=[\n            '/clock@rosgraph_msgs/msg/Clock[gz.msgs.Clock',\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo,\n        bridge,\n    ])\n"})}),"\n",(0,s.jsx)(e.p,{children:"Launch with:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"ros2 launch your_package gazebo_sim.launch.py\n"})}),"\n",(0,s.jsx)(e.h2,{id:"creating-a-humanoid-robot-model",children:"Creating a Humanoid Robot Model"}),"\n",(0,s.jsx)(e.h3,{id:"sdf-format",children:"SDF Format"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo uses SDF (Simulation Description Format) for robot models. Here's a simplified humanoid structure:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.9">\n  <model name="simple_humanoid">\n    \x3c!-- Torso --\x3e\n    <link name="torso">\n      <pose>0 0 1.0 0 0 0</pose>\n      <inertial>\n        <mass>30.0</mass>\n        <inertia>\n          <ixx>1.0</ixx>\n          <iyy>1.0</iyy>\n          <izz>0.5</izz>\n        </inertia>\n      </inertial>\n      <collision name="torso_collision">\n        <geometry>\n          <box>\n            <size>0.4 0.3 0.6</size>\n          </box>\n        </geometry>\n      </collision>\n      <visual name="torso_visual">\n        <geometry>\n          <box>\n            <size>0.4 0.3 0.6</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.5 0.5 0.5 1</ambient>\n          <diffuse>0.8 0.8 0.8 1</diffuse>\n        </material>\n      </visual>\n    </link>\n\n    \x3c!-- Head --\x3e\n    <link name="head">\n      <pose>0 0 1.45 0 0 0</pose>\n      <inertial>\n        <mass>5.0</mass>\n        <inertia>\n          <ixx>0.1</ixx>\n          <iyy>0.1</iyy>\n          <izz>0.1</izz>\n        </inertia>\n      </inertial>\n      <collision name="head_collision">\n        <geometry>\n          <sphere>\n            <radius>0.15</radius>\n          </sphere>\n        </geometry>\n      </collision>\n      <visual name="head_visual">\n        <geometry>\n          <sphere>\n            <radius>0.15</radius>\n          </sphere>\n        </geometry>\n        <material>\n          <ambient>0.9 0.7 0.6 1</ambient>\n          <diffuse>0.9 0.7 0.6 1</diffuse>\n        </material>\n      </visual>\n\n      \x3c!-- Camera Sensor --\x3e\n      <sensor name="head_camera" type="camera">\n        <pose>0.1 0 0 0 0 0</pose>\n        <camera>\n          <horizontal_fov>1.047</horizontal_fov>\n          <image>\n            <width>640</width>\n            <height>480</height>\n          </image>\n          <clip>\n            <near>0.1</near>\n            <far>100</far>\n          </clip>\n        </camera>\n        <always_on>1</always_on>\n        <update_rate>30</update_rate>\n        <visualize>true</visualize>\n      </sensor>\n    </link>\n\n    \x3c!-- Neck Joint --\x3e\n    <joint name="neck_joint" type="revolute">\n      <parent>torso</parent>\n      <child>head</child>\n      <axis>\n        <xyz>0 0 1</xyz>\n        <limit>\n          <lower>-1.57</lower>\n          <upper>1.57</upper>\n        </limit>\n      </axis>\n    </joint>\n\n    \x3c!-- Add arms, legs, and other components... --\x3e\n\n  </model>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"spawning-robots-in-gazebo",children:"Spawning Robots in Gazebo"}),"\n",(0,s.jsx)(e.h3,{id:"method-1-using-launch-files",children:"Method 1: Using Launch Files"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from launch_ros.actions import Node\n\ndef generate_launch_description():\n    # ... previous gazebo launch code ...\n\n    # Spawn robot\n    spawn_robot = Node(\n        package='ros_gz_sim',\n        executable='create',\n        arguments=[\n            '-name', 'my_humanoid',\n            '-file', '/path/to/humanoid.sdf',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '1.0',\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo,\n        bridge,\n        spawn_robot,\n    ])\n"})}),"\n",(0,s.jsx)(e.h3,{id:"method-2-using-ros-2-service",children:"Method 2: Using ROS 2 Service"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Spawn using service call\nros2 service call /world/empty/create entity_name:="my_humanoid" file_path:="/path/to/humanoid.sdf" pose:="{position: {x: 0.0, y: 0.0, z: 1.0}}"\n'})}),"\n",(0,s.jsx)(e.h2,{id:"controlling-robots-in-gazebo",children:"Controlling Robots in Gazebo"}),"\n",(0,s.jsx)(e.h3,{id:"joint-control-plugin",children:"Joint Control Plugin"}),"\n",(0,s.jsx)(e.p,{children:"Add to your SDF model:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<plugin filename="gz-sim-joint-controller-system" name="gz::sim::systems::JointController">\n  <joint_name>neck_joint</joint_name>\n</plugin>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"publishing-joint-commands",children:"Publishing Joint Commands"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64\n\nclass JointCommandPublisher(Node):\n    def __init__(self):\n        super().__init__('joint_command_publisher')\n        self.publisher = self.create_publisher(\n            Float64,\n            '/model/my_humanoid/joint/neck_joint/cmd_pos',\n            10\n        )\n        self.timer = self.create_timer(0.1, self.publish_command)\n        self.angle = 0.0\n\n    def publish_command(self):\n        msg = Float64()\n        msg.data = self.angle\n        self.publisher.publish(msg)\n        # Oscillate neck\n        self.angle += 0.05\n        if abs(self.angle) > 1.0:\n            self.angle *= -1\n\ndef main():\n    rclpy.init()\n    node = JointCommandPublisher()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,s.jsx)(e.h3,{id:"camera-feed-to-ros-2",children:"Camera Feed to ROS 2"}),"\n",(0,s.jsx)(e.p,{children:"Bridge camera data:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# In your launch file, add to bridge arguments:\nbridge_args = [\n    '/camera@sensor_msgs/msg/Image[gz.msgs.Image',\n    '/camera_info@sensor_msgs/msg/CameraInfo[gz.msgs.CameraInfo',\n]\n\nbridge = Node(\n    package='ros_gz_bridge',\n    executable='parameter_bridge',\n    arguments=bridge_args,\n    output='screen'\n)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"imu-sensor",children:"IMU Sensor"}),"\n",(0,s.jsx)(e.p,{children:"Add IMU to your robot:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu_sensor" type="imu">\n  <always_on>1</always_on>\n  <update_rate>100</update_rate>\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </x>\n      \x3c!-- Add y and z... --\x3e\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </x>\n      \x3c!-- Add y and z... --\x3e\n    </linear_acceleration>\n  </imu>\n</sensor>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Model Organization"}),": Keep robot models in separate packages with clear structure"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Tuning"}),": Adjust physics parameters (step size, iterations) for stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Noise"}),": Add realistic noise to sensors for robust algorithm development"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Performance"}),": Use lower update rates for non-critical sensors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Version Control"}),": Track SDF models and world files in version control"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Gazebo crashes on launch:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Check graphics driver\nglxinfo | grep "OpenGL version"\n\n# Try software rendering\nexport LIBGL_ALWAYS_SOFTWARE=1\ngz sim\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Robot falls through ground:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Check collision geometries"}),"\n",(0,s.jsx)(e.li,{children:"Verify mass and inertia values"}),"\n",(0,s.jsx)(e.li,{children:"Ensure proper contact parameters"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Slow simulation:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Reduce sensor update rates"}),"\n",(0,s.jsx)(e.li,{children:"Simplify collision meshes"}),"\n",(0,s.jsx)(e.li,{children:"Disable unnecessary plugins"}),"\n",(0,s.jsx)(e.li,{children:"Lower real-time factor"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(e.p,{children:"In the next lesson, you'll learn to set up Unity with the ROS-TCP-Connector for more advanced graphics and simulation scenarios."}),"\n",(0,s.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://gazebosim.org/docs",children:"Gazebo Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"http://sdformat.org/",children:"SDF Specification"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/gazebosim/ros_gz",children:"ros_gz Repository"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);